= interrupt(3)
:doctype: manpage
:manmanual: Manual for libsimplegba
:mansource: libsimplegba
:revdate: 2025-12-26
:docdate: {revdate}

== NAME
interrupt_toggle, interrupt_set_isr, interrupt_wait - interrupt handling

== SYNOPSIS
[verse]
____
*#include <libsimplegba.h>*

**void interrupt_toggle(i32 **__id__**, bool **__enable__**);**
**void interrupt_set_isr(i32 **__id__**, void (+++*+++**__isr__**)(void));**
**void interrupt_wait(i32 **__id__**);**
____

== DESCRIPTION
Interrupts are signals generated by specific events that pause the
normal flow of execution. Interrupts can be assigned an ISR (Interrupt
Service Routine), a function to execute right after the interrupt is
acknowledged. If an interrupt is raised while an ISR is running, the
interrupt is handled after the ISR returns.

The *interrupt_toggle*() function enables or disables the interrupt,
based on the value of _enable_.

The *interrupt_set_isr*() function maps the interrupt to its _isr_. If
_isr_ is NULL, no action is performed when that interrupt is raised,
other than acknowledging it.

The *interrupt_wait*() function waits for the interrupt to be raised,
then returns.

=== Interrupts
Interrupts are identified by the constants described below.

*IRQ_VBLANK*::
Periodically raised at the start of VBlank, after the last row of pixels
is rendered, with an approximate frequency of 59.73 Hz.

*IRQ_HBLANK*::
Periodically raised at the start of HBlank, after the last column of
pixels is rendered for each row (including hidden rows), with an
approximate frequency of 13.62 KHz.

*IRQ_VCOUNT*::
Periodically raised when the display's VCount reaches the configured
number, with an approximate frequency of 59.73 Hz. TODO

*IRQ_TIMER0*, *IRQ_TIMER1*, *IRQ_TIMER2*, *IRQ_TIMER3*::
Raised when a timer's counter reaches zero. See *timer_config*(3).

*IRQ_DMA0*, *IRQ_DMA1*, *IRQ_DMA2*, *IRQ_DMA3*::
Raised when a DMA transfer is complete. See *dma_config*(3).

*IRQ_KEYPAD*::
TODO

*IRQ_GAMEPAK*::
Raised when the game cartridge is removed. Some cartridges may also
raise it to signal special events.

*IRQ_SERIAL*::
TODO

== NOTES
Each interrupt can only be mapped to one ISR at a time, meaning that
calling *interrupt_set_isr*() overwrites the previous association. If an
interrupt needs multiple ISRs, the recommended approach is to write a
wrapper function:

[source,c]
----
void foo_isr(void) {
    foo_isr_a();
    foo_isr_b();
}
----

== EXAMPLES
Enable the VBlank interrupt and map an ISR to it:

[source,c]
----
int AgbMain(void) {
    interrupt_toggle(IRQ_VBLANK, true);
    interrupt_set_isr(IRQ_VBLANK, vblank_isr);
}
----

== AUTHORS
The *libsimplegba* library was written by Vulcalien
<\vulcalien@vulcalien.net>.
