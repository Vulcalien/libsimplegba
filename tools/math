#!/usr/bin/env python3

# Copyright 2025 Vulcalien
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.

import math
from statistics import mean

# === Function Classes === #

class Function:
    def test(self, dump=False):
        targets = [ self.target(i)         for i in self.range() ]
        values  = [ self.get(i)            for i in self.range() ]
        errors  = [ targets[i] - values[i] for i in self.range() ]

        if dump:
            for i in self.range():
                print(i, targets[i], values[i], errors[i])

        print()
        print('Error:')
        print('  Min: %d' % min(errors))
        print('  Max: %d' % max(errors))
        print('  Count: %d' % sum(e != 0 for e in errors))
        print('  Average: %.5f' % mean(errors))
        print('  Root Mean Square: %.5f'
              % math.sqrt(mean(e ** 2 for e in errors)))

    # range in which to test the function
    def range(self):
        raise NotImplementedError()

    # the target value, which the function tries to approximate
    def target(self, x):
        raise NotImplementedError()

    # the approximated value
    def get(self, x):
        raise NotImplementedError()

class LutFunction(Function):
    def __init__(self, scale, covered_range):
        self.scale = scale
        self.covered_range = covered_range
        self.lut = [
            self.get_lut_entry(i)
            for i in range(covered_range // self.scale + 1)
        ]

    def range(self):
        return range(self.covered_range)

    def get(self, x):
        index = x // self.scale
        left = self.lut[index]
        right = self.lut[index + 1] if index + 1 < len(self.lut) else 0
        return left + (right - left) * (x % self.scale) // self.scale

    def print_lut(self, entry_format, entries_per_line, line_prefix):
        for i in range(len(self.lut)):
            if i % entries_per_line == 0:
                print('\n' + line_prefix, end='')
            print(entry_format % self.lut[i], end='')
        print()

    def get_lut_entry(self, i):
        raise NotImplementedError()

# === Trigonometric Functions === #

class Sin(LutFunction):
    def __init__(self):
        super().__init__(128, 0x8000 + 1)

    def target(self, x):
        x *= math.pi / 0x8000
        y = math.sin(x) * 0x4000
        return int(y)

    def get_lut_entry(self, i):
        x = i * self.scale * math.pi / 0x8000
        y = math.sin(x) * 0x4000 + 0.5
        return int(y)

class Tan(LutFunction):
    def __init__(self):
        super().__init__(32, 0x4000)
        self.lut[-1] = int(
            (0xffffffff - self.lut[-2]) / (self.scale - 1)
        )

    def target(self, x):
        x *= math.pi / 0x8000
        y = math.tan(x) * 0x4000
        return int(y + 0.0001)

    def get_lut_entry(self, i):
        x = i * self.scale * math.pi / 0x8000
        y = math.tan(x) * 0x4000
        return int(y + 0.0001)

class Asin(LutFunction):
    def __init__(self):
        super().__init__(32, 0x4000 + 1)

    def target(self, x):
        x /= 0x4000
        y = math.asin(x) * 0x8000 / math.pi
        return int(y)

    def get_lut_entry(self, i):
        x = i * self.scale / 0x4000
        y = math.asin(x) * 0x8000 / math.pi
        return int(y)

# Sin().print_lut('0x%04x, ', 8, '  .short ')
# Tan().print_lut('0x%06x, ', 6, '    ')
# Asin().print_lut('0x%04x, ', 8, '  .short ')

Sin().test()
Tan().test()
Asin().test()
