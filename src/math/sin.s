@ Copyright 2024-2025 Vulcalien
@
@ This program is free software: you can redistribute it and/or modify
@ it under the terms of the GNU General Public License as published by
@ the Free Software Foundation, either version 3 of the License, or
@ (at your option) any later version.
@
@ This program is distributed in the hope that it will be useful,
@ but WITHOUT ANY WARRANTY; without even the implied warranty of
@ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
@ GNU General Public License for more details.
@
@ You should have received a copy of the GNU General Public License
@ along with this program. If not, see <https://www.gnu.org/licenses/>.

.include "assembly.inc"

.equ SCALE_SHIFT, 7

@ --- sin_lut --- @
.section .rodata
.align 1

@ u16 sin_lut[0x8000 / SCALE + 1]
sin_lut:
  .short 0x0000, 0x00c9, 0x0192, 0x025b, 0x0324, 0x03ed, 0x04b5, 0x057e
  .short 0x0646, 0x070e, 0x07d6, 0x089d, 0x0964, 0x0a2b, 0x0af1, 0x0bb7
  .short 0x0c7c, 0x0d41, 0x0e06, 0x0eca, 0x0f8d, 0x1050, 0x1112, 0x11d3
  .short 0x1294, 0x1354, 0x1413, 0x14d2, 0x1590, 0x164c, 0x1709, 0x17c4
  .short 0x187e, 0x1937, 0x19ef, 0x1aa7, 0x1b5d, 0x1c12, 0x1cc6, 0x1d79
  .short 0x1e2b, 0x1edc, 0x1f8c, 0x203a, 0x20e7, 0x2193, 0x223d, 0x22e7
  .short 0x238e, 0x2435, 0x24da, 0x257e, 0x2620, 0x26c1, 0x2760, 0x27fe
  .short 0x289a, 0x2935, 0x29ce, 0x2a65, 0x2afb, 0x2b8f, 0x2c21, 0x2cb2
  .short 0x2d41, 0x2dcf, 0x2e5a, 0x2ee4, 0x2f6c, 0x2ff2, 0x3076, 0x30f9
  .short 0x3179, 0x31f8, 0x3274, 0x32ef, 0x3368, 0x33df, 0x3453, 0x34c6
  .short 0x3537, 0x35a5, 0x3612, 0x367d, 0x36e5, 0x374b, 0x37b0, 0x3812
  .short 0x3871, 0x38cf, 0x392b, 0x3984, 0x39db, 0x3a30, 0x3a82, 0x3ad3
  .short 0x3b21, 0x3b6d, 0x3bb6, 0x3bfd, 0x3c42, 0x3c85, 0x3cc5, 0x3d03
  .short 0x3d3f, 0x3d78, 0x3daf, 0x3de3, 0x3e15, 0x3e45, 0x3e72, 0x3e9d
  .short 0x3ec5, 0x3eeb, 0x3f0f, 0x3f30, 0x3f4f, 0x3f6b, 0x3f85, 0x3f9c
  .short 0x3fb1, 0x3fc4, 0x3fd4, 0x3fe1, 0x3fec, 0x3ff5, 0x3ffb, 0x3fff
  .short 0x4000, 0x3fff, 0x3ffb, 0x3ff5, 0x3fec, 0x3fe1, 0x3fd4, 0x3fc4
  .short 0x3fb1, 0x3f9c, 0x3f85, 0x3f6b, 0x3f4f, 0x3f30, 0x3f0f, 0x3eeb
  .short 0x3ec5, 0x3e9d, 0x3e72, 0x3e45, 0x3e15, 0x3de3, 0x3daf, 0x3d78
  .short 0x3d3f, 0x3d03, 0x3cc5, 0x3c85, 0x3c42, 0x3bfd, 0x3bb6, 0x3b6d
  .short 0x3b21, 0x3ad3, 0x3a82, 0x3a30, 0x39db, 0x3984, 0x392b, 0x38cf
  .short 0x3871, 0x3812, 0x37b0, 0x374b, 0x36e5, 0x367d, 0x3612, 0x35a5
  .short 0x3537, 0x34c6, 0x3453, 0x33df, 0x3368, 0x32ef, 0x3274, 0x31f8
  .short 0x3179, 0x30f9, 0x3076, 0x2ff2, 0x2f6c, 0x2ee4, 0x2e5a, 0x2dcf
  .short 0x2d41, 0x2cb2, 0x2c21, 0x2b8f, 0x2afb, 0x2a65, 0x29ce, 0x2935
  .short 0x289a, 0x27fe, 0x2760, 0x26c1, 0x2620, 0x257e, 0x24da, 0x2435
  .short 0x238e, 0x22e7, 0x223d, 0x2193, 0x20e7, 0x203a, 0x1f8c, 0x1edc
  .short 0x1e2b, 0x1d79, 0x1cc6, 0x1c12, 0x1b5d, 0x1aa7, 0x19ef, 0x1937
  .short 0x187e, 0x17c4, 0x1709, 0x164c, 0x1590, 0x14d2, 0x1413, 0x1354
  .short 0x1294, 0x11d3, 0x1112, 0x1050, 0x0f8d, 0x0eca, 0x0e06, 0x0d41
  .short 0x0c7c, 0x0bb7, 0x0af1, 0x0a2b, 0x0964, 0x089d, 0x07d6, 0x070e
  .short 0x0646, 0x057e, 0x04b5, 0x03ed, 0x0324, 0x025b, 0x0192, 0x00c9
  .short 0x0000
.size sin_lut, .-sin_lut

@ --- math_sin --- @

@ The LUT contains entries for angles in [0, 180] deg.
@
@ Results for angles in (180, 360) deg are obtained using the property:
@   sin(180 + x) = -sin(x)

@ register allocation:
@   r0 = left, result
@   r1 = angle
@   r2 = right, delta
@   r3 = weight

@ input:
@   r0 = angle : i32
@ output:
@   r0 = result : i32
BEGIN_GLOBAL_FUNC .text THUMB math_sin
    @ normalize angle in range [0, 360) degrees
    lsls    r1, r0, #16
    lsrs    r1, #16                     @ (r1) angle &= 0xffff

    @ retrieve LUT entries
    ldr     r0, =sin_lut
    lsls    r2, r1, #17
    lsrs    r2, #(17 + SCALE_SHIFT)     @ index = (angle % 180 deg) / SCALE
    lsls    r2, #1                      @ index * 2
    adds    r2, r0                      @ &sin_lut[index]
    ldrh    r0, [r2]                    @ (r0) left  = sin_lut[index]
    ldrh    r2, [r2, #2]                @ (r2) right = sin_lut[index + 1]

    @ interpolate entries: left + (right - left) * weight / SCALE
    lsls    r3, r1, #(32 - SCALE_SHIFT)
    lsrs    r3, #(32 - SCALE_SHIFT)     @ (r3) weight = angle % SCALE
    subs    r2, r0                      @ (r2) delta = right - left
    muls    r2, r3                      @ delta *= weight
    asrs    r2, #SCALE_SHIFT            @ delta /= SCALE
    adds    r0, r2                      @ (r0) result = left + delta

    @ If angle > 180 deg, adjust sign of result.
    @ Since angle is in range [0, 360) deg, i.e. [0, 0xffff],
    @ if bit 15 is set, then angle >= 180 deg.
    lsrs    r1, #15                     @ check bit 15 of angle
    beq     .L_do_not_adjust            @ if bit 15 clear, do not adjust
    negs    r0, r0                      @ (r0) result = -result
.L_do_not_adjust:

    bx      lr
END_FUNC math_sin

.end
